#!/usr/bin/env pwsh
# Sync-DREnvironment.ps1
#
# This script automates the creation of DR resources in South Central US based on existing
# resources in North Central US. It discovers resource groups and resources in the primary region,
# and creates corresponding resources in the DR region with a "dr" suffix.

param(
    [Parameter(Mandatory=$false)]
    [string]$SubscriptionId = "",
    
    [Parameter(Mandatory=$false)]
    [string]$PrimaryRegion = "northcentralus",
    
    [Parameter(Mandatory=$false)]
    [string]$DRRegion = "southcentralus",
    
    [Parameter(Mandatory=$false)]
    [string]$DRSuffix = "dr",
    
    [Parameter(Mandatory=$false)]
    [string]$ResourceGroupFilter = "*",
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipExistingResources,
    
    [Parameter(Mandatory=$false)]
    [switch]$WhatIf
)

#region Functions

function Write-LogMessage {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("Info", "Warning", "Error", "Success")]
        [string]$Level = "Info"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    switch ($Level) {
        "Info"    { Write-Host "[$timestamp] INFO:    $Message" -ForegroundColor Cyan }
        "Warning" { Write-Host "[$timestamp] WARNING: $Message" -ForegroundColor Yellow }
        "Error"   { Write-Host "[$timestamp] ERROR:   $Message" -ForegroundColor Red }
        "Success" { Write-Host "[$timestamp] SUCCESS: $Message" -ForegroundColor Green }
    }
}

function Export-ResourceGroupToTerraform {
    param (
        [Parameter(Mandatory=$true)]
        [string]$ResourceGroupName,
        
        [Parameter(Mandatory=$true)]
        [string]$OutputDirectory
    )
    
    # Create output directory if it doesn't exist
    if (-not (Test-Path -Path $OutputDirectory)) {
        New-Item -Path $OutputDirectory -ItemType Directory | Out-Null
    }
    
    Write-LogMessage "Exporting resource group $ResourceGroupName to Terraform configuration..."
    
    # Get resources in the resource group
    $resources = az resource list --resource-group $ResourceGroupName --query "[].{id:id, type:type, name:name}" -o json | ConvertFrom-Json
    
    # Create main.tf file
    $mainTfContent = @"
# Terraform configuration for resource group $ResourceGroupName
# Auto-generated by Sync-DREnvironment.ps1 on $(Get-Date -Format "yyyy-MM-dd")

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.70.0"
    }
  }
  backend "azurerm" {
    # Backend configuration will be provided via -backend-config parameters
  }
}

provider "azurerm" {
  features {}
}

# Resource Group
resource "azurerm_resource_group" "main" {
  name     = "${ResourceGroupName.Replace($PrimaryRegion, $DRRegion)}$DRSuffix"
  location = "$DRRegion"
  tags     = {
    Source = "$ResourceGroupName"
    DR     = "True"
  }
}
"@
    
    $mainTfPath = Join-Path -Path $OutputDirectory -ChildPath "main.tf"
    $mainTfContent | Out-File -FilePath $mainTfPath -Encoding utf8
    Write-LogMessage "Created $mainTfPath" -Level "Success"
    
    # Create resources.tf file with all resources
    $resourcesTfContent = "# Resources from resource group $ResourceGroupName`n"
    
    # Add code for each resource type
    foreach ($resource in $resources) {
        # Skip resource types that shouldn't be replicated
        $skipTypes = @(
            "Microsoft.Resources/resourceGroups",
            "Microsoft.Sql/servers/databases" # SQL databases are already configured with geo-replication
        )
        
        if ($resource.type -in $skipTypes) {
            continue
        }
        
        # For compute resources, replace region in the name and add DR suffix
        if ($resource.type -in @(
            "Microsoft.Web/sites",
            "Microsoft.Web/serverFarms",
            "Microsoft.ContainerInstance/containerGroups",
            "Microsoft.ContainerService/managedClusters"
        )) {
            $resourceDetails = az resource show --ids $resource.id -o json | ConvertFrom-Json
            $newName = $resource.name.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $resourcesTfContent += @"
# $($resource.type): $($resource.name) -> $newName
# TODO: Implement Terraform resource block for this resource type
# Use the azurerm_$($resource.type.ToLower().Replace("/", "_")) resource type
# Example:
# resource "azurerm_$($resource.type.ToLower().Replace("/", "_"))" "$($resource.name)" {
#   name                = "$newName"
#   location            = azurerm_resource_group.main.location
#   resource_group_name = azurerm_resource_group.main.name
#   # Additional properties needed...
# }

"@
        }
    }
    
    $resourcesTfPath = Join-Path -Path $OutputDirectory -ChildPath "resources.tf"
    $resourcesTfContent | Out-File -FilePath $resourcesTfPath -Encoding utf8
    Write-LogMessage "Created $resourcesTfPath" -Level "Success"
    
    # Create variables.tf file
    $variablesTfContent = @"
variable "region" {
  description = "Azure region to deploy resources"
  type        = string
  default     = "$DRRegion"
}

variable "environment" {
  description = "Environment name (dev, test, prod)"
  type        = string
  default     = "dr"
}

variable "deploy_compute" {
  description = "Whether to deploy compute resources"
  type        = bool
  default     = false
}
"@
    
    $variablesTfPath = Join-Path -Path $OutputDirectory -ChildPath "variables.tf"
    $variablesTfContent | Out-File -FilePath $variablesTfPath -Encoding utf8
    Write-LogMessage "Created $variablesTfPath" -Level "Success"
    
    # Create backend.tf file
    $backendTfContent = @"
/**
 * # Terraform State Backend Configuration
 * 
 * This file configures the Azure Storage backend for Terraform state management.
 * The actual configuration parameters are NOT hardcoded in this file but provided
 * at runtime using the -backend-config flag with terraform init.
 * 
 * ## Usage Example
 * 
 * ```powershell
 * terraform init `
 *   -backend-config="resource_group_name=tfstate-rg" `
 *   -backend-config="storage_account_name=mytfstate1234" `
 *   -backend-config="container_name=tfstate" `
 *   -backend-config="key=scus/${ResourceGroupName}$DRSuffix.tfstate"
 * ```
 */

terraform {
  backend "azurerm" {
    # Backend configuration will be provided via -backend-config parameters
  }
}
"@
    
    $backendTfPath = Join-Path -Path $OutputDirectory -ChildPath "backend.tf"
    $backendTfContent | Out-File -FilePath $backendTfPath -Encoding utf8
    Write-LogMessage "Created $backendTfPath" -Level "Success"
    
    # Create compute.tf file with conditional deployment
    $computeTfContent = @"
/**
 * # Compute Resources (DR Region - $DRRegion)
 * These resources are the on-demand compute components, only deployed during DR events.
 * They are conditionally deployed based on the deploy_compute variable.
 */

# App Service Plans
locals {
  app_service_plans = {
    # Example:
    # "plan-name" = {
    #   os_type = "Linux" # or "Windows"
    #   sku_name = "P1v2"
    #   is_ase = false
    # }
  }
  
  app_services = {
    # Example:
    # "app-name" = {
    #   plan_key = "plan-name" # References a key in app_service_plans
    #   os_type = "Linux" # or "Windows"
    #   settings = {
    #     "WEBSITE_DNS_SERVER" = "168.63.129.16"
    #     "DISASTER_RECOVERY_MODE" = "true"
    #   }
    # }
  }
  
  function_apps = {
    # Example:
    # "function-name" = {
    #   plan_key = "plan-name" # References a key in app_service_plans
    #   os_type = "Linux" # or "Windows"
    #   settings = {
    #     "WEBSITE_DNS_SERVER" = "168.63.129.16"
    #     "DISASTER_RECOVERY_MODE" = "true"
    #   }
    # }
  }
  
  container_apps = {
    # Example:
    # "container-app-name" = {
    #   image = "mcr.microsoft.com/azuredocs/containerapps-helloworld:latest"
    #   environment_variables = {
    #     "DISASTER_RECOVERY_MODE" = "true"
    #   }
    # }
  }
}

# Linux App Service Plans
module "app_service_plan_linux" {
  for_each            = var.deploy_compute ? {
    for name, plan in local.app_service_plans :
    name => plan if plan.os_type == "Linux" && !plan.is_ase
  } : {}
  
  source              = "../../../modules/app_service_plan"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Linux"
  sku_name            = each.value.sku_name
  # No ASE ID for public app service plans
  tags                = azurerm_resource_group.main.tags
}

# Windows App Service Plans
module "app_service_plan_windows" {
  for_each            = var.deploy_compute ? {
    for name, plan in local.app_service_plans :
    name => plan if plan.os_type == "Windows" && !plan.is_ase
  } : {}
  
  source              = "../../../modules/app_service_plan"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Windows"
  sku_name            = each.value.sku_name
  # No ASE ID for public app service plans
  tags                = azurerm_resource_group.main.tags
}

# Linux App Services
module "app_service_linux" {
  for_each            = var.deploy_compute ? {
    for name, app in local.app_services :
    name => app if app.os_type == "Linux"
  } : {}
  
  source              = "../../../modules/app_service"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Linux"
  app_service_plan_id = module.app_service_plan_linux[each.value.plan_key].id
  app_settings        = each.value.settings
  tags                = azurerm_resource_group.main.tags
}

# Windows App Services
module "app_service_windows" {
  for_each            = var.deploy_compute ? {
    for name, app in local.app_services :
    name => app if app.os_type == "Windows"
  } : {}
  
  source              = "../../../modules/app_service"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Windows"
  app_service_plan_id = module.app_service_plan_windows[each.value.plan_key].id
  app_settings        = each.value.settings
  tags                = azurerm_resource_group.main.tags
}

# Linux Function Apps
module "function_app_linux" {
  for_each            = var.deploy_compute ? {
    for name, app in local.function_apps :
    name => app if app.os_type == "Linux"
  } : {}
  
  source              = "../../../modules/function_app"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Linux"
  app_service_plan_id = module.app_service_plan_linux[each.value.plan_key].id
  app_settings        = each.value.settings
  tags                = azurerm_resource_group.main.tags
}

# Windows Function Apps
module "function_app_windows" {
  for_each            = var.deploy_compute ? {
    for name, app in local.function_apps :
    name => app if app.os_type == "Windows"
  } : {}
  
  source              = "../../../modules/function_app"
  region              = var.region
  environment         = var.environment
  resource_group_name = azurerm_resource_group.main.name
  name                = each.key
  os_type             = "Windows"
  app_service_plan_id = module.app_service_plan_windows[each.value.plan_key].id
  app_settings        = each.value.settings
  tags                = azurerm_resource_group.main.tags
}

# Container Apps
module "container_app" {
  for_each                    = var.deploy_compute ? local.container_apps : {}
  source                      = "../../../modules/container_app"
  region                      = var.region
  environment                 = var.environment
  resource_group_name         = azurerm_resource_group.main.name
  name                        = each.key
  container_image             = each.value.image
  environment_variables       = each.value.environment_variables
  tags                        = azurerm_resource_group.main.tags
}
"@
    
    $computeTfPath = Join-Path -Path $OutputDirectory -ChildPath "compute.tf"
    $computeTfContent | Out-File -FilePath $computeTfPath -Encoding utf8
    Write-LogMessage "Created $computeTfPath" -Level "Success"
    
    return $OutputDirectory
}

function Analyze-ComputeResources {
    param (
        [Parameter(Mandatory=$true)]
        [string]$ResourceGroupName
    )
    
    Write-LogMessage "Analyzing compute resources in $ResourceGroupName..."
    
    # Get all App Service Plans
    $appServicePlans = az appservice plan list --resource-group $ResourceGroupName --query "[].{name:name, kind:kind, sku:sku.name, location:location}" -o json | ConvertFrom-Json
    
    # Get all App Services
    $appServices = az webapp list --resource-group $ResourceGroupName --query "[].{name:name, kind:kind, plan:appServicePlanId, location:location, settings:siteConfig}" -o json | ConvertFrom-Json
    
    # Get all Function Apps
    $functionApps = az functionapp list --resource-group $ResourceGroupName --query "[].{name:name, kind:kind, plan:appServicePlanId, location:location, settings:siteConfig}" -o json | ConvertFrom-Json
    
    # Get all Container Apps
    $containerApps = az containerapp list --resource-group $ResourceGroupName --query "[].{name:name, location:location, environment:managedEnvironmentId, image:template.containers[0].image}" -o json 2>$null | ConvertFrom-Json
    
    $result = @{
        ResourceGroup = $ResourceGroupName
        AppServicePlans = $appServicePlans
        AppServices = $appServices
        FunctionApps = $functionApps
        ContainerApps = $containerApps
    }
    
    return $result
}

function Generate-ResourceTerraformConfig {
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$ComputeResources,
        
        [Parameter(Mandatory=$true)]
        [string]$OutputDirectory
    )
    
    $planLocals = @()
    $appLocals = @()
    $functionLocals = @()
    $containerLocals = @()
    
    # Process App Service Plans
    if ($ComputeResources.AppServicePlans) {
        foreach ($plan in $ComputeResources.AppServicePlans) {
            $isLinux = $plan.kind -like "*linux*"
            $osType = if ($isLinux) { "Linux" } else { "Windows" }
            $isAse = $plan.kind -like "*hostingEnvironments*" -or $plan.kind -like "*ase*"
            
            $newName = $plan.name.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            $planLocals += @"
    "$newName" = {
      os_type = "$osType"
      sku_name = "$($plan.sku)"
      is_ase = $($isAse.ToString().ToLower())
    }
"@
        }
    }
    
    # Process App Services
    if ($ComputeResources.AppServices) {
        foreach ($app in $ComputeResources.AppServices) {
            $isLinux = $app.kind -like "*linux*"
            $osType = if ($isLinux) { "Linux" } else { "Windows" }
            
            # Get plan name from ID
            $planIdParts = $app.plan -split "/"
            $planName = $planIdParts[-1]
            $newPlanName = $planName.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $newName = $app.name.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $settings = @{
                "DISASTER_RECOVERY_MODE" = "true"
            }
            
            $settingsStr = "{\n      " + ($settings.GetEnumerator() | ForEach-Object { "`"$($_.Key)`" = `"$($_.Value)`"" }) -join "\n      " + "\n    }"
            
            $appLocals += @"
    "$newName" = {
      plan_key = "$newPlanName"
      os_type = "$osType"
      settings = $settingsStr
    }
"@
        }
    }
    
    # Process Function Apps
    if ($ComputeResources.FunctionApps) {
        foreach ($func in $ComputeResources.FunctionApps) {
            $isLinux = $func.kind -like "*linux*"
            $osType = if ($isLinux) { "Linux" } else { "Windows" }
            
            # Get plan name from ID
            $planIdParts = $func.plan -split "/"
            $planName = $planIdParts[-1]
            $newPlanName = $planName.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $newName = $func.name.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $settings = @{
                "DISASTER_RECOVERY_MODE" = "true"
                "FUNCTIONS_WORKER_RUNTIME" = "dotnet"
            }
            
            $settingsStr = "{\n      " + ($settings.GetEnumerator() | ForEach-Object { "`"$($_.Key)`" = `"$($_.Value)`"" }) -join "\n      " + "\n    }"
            
            $functionLocals += @"
    "$newName" = {
      plan_key = "$newPlanName"
      os_type = "$osType"
      settings = $settingsStr
    }
"@
        }
    }
    
    # Process Container Apps
    if ($ComputeResources.ContainerApps) {
        foreach ($container in $ComputeResources.ContainerApps) {
            $newName = $container.name.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
            
            $envVars = @{
                "DISASTER_RECOVERY_MODE" = "true"
            }
            
            $envVarsStr = "{\n      " + ($envVars.GetEnumerator() | ForEach-Object { "`"$($_.Key)`" = `"$($_.Value)`"" }) -join "\n      " + "\n    }"
            
            $containerLocals += @"
    "$newName" = {
      image = "$($container.image)"
      environment_variables = $envVarsStr
    }
"@
        }
    }
    
    # Update compute.tf file with discovered resources
    $computeTfPath = Join-Path -Path $OutputDirectory -ChildPath "compute.tf"
    $computeTfContent = Get-Content -Path $computeTfPath -Raw
    
    $plansLocalContent = "  app_service_plans = {\n" + ($planLocals -join "\n\n") + "\n  }"
    $appsLocalContent = "  app_services = {\n" + ($appLocals -join "\n\n") + "\n  }"
    $functionsLocalContent = "  function_apps = {\n" + ($functionLocals -join "\n\n") + "\n  }"
    $containersLocalContent = "  container_apps = {\n" + ($containerLocals -join "\n\n") + "\n  }"
    
    $computeTfContent = $computeTfContent -replace "  app_service_plans = \{[^}]*\}", $plansLocalContent
    $computeTfContent = $computeTfContent -replace "  app_services = \{[^}]*\}", $appsLocalContent
    $computeTfContent = $computeTfContent -replace "  function_apps = \{[^}]*\}", $functionsLocalContent
    $computeTfContent = $computeTfContent -replace "  container_apps = \{[^}]*\}", $containersLocalContent
    
    $computeTfContent | Out-File -FilePath $computeTfPath -Encoding utf8
    Write-LogMessage "Updated $computeTfPath with discovered resources" -Level "Success"
}

#endregion

#region Main Script

# Check if Azure CLI is installed
if (-not (Get-Command az -ErrorAction SilentlyContinue)) {
    Write-LogMessage "Azure CLI not found. Please install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli" -Level "Error"
    exit 1
}

# Check Azure login status
Write-LogMessage "Checking Azure login status..."
try {
    $account = az account show | ConvertFrom-Json
    Write-LogMessage "Logged in as $($account.user.name)" -Level "Success"
} catch {
    Write-LogMessage "Not logged in to Azure. Please log in." -Level "Warning"
    az login
}

# Set subscription if provided
if ($SubscriptionId) {
    Write-LogMessage "Setting subscription to $SubscriptionId..."
    az account set --subscription $SubscriptionId
    if ($LASTEXITCODE -ne 0) {
        Write-LogMessage "Failed to set subscription. Please check the subscription ID." -Level "Error"
        exit 1
    }
}

# Get current subscription
$currentSubscription = az account show | ConvertFrom-Json
Write-LogMessage "Using subscription: $($currentSubscription.name) ($($currentSubscription.id))" -Level "Info"

# Get resource groups in the primary region
Write-LogMessage "Getting resource groups in $PrimaryRegion..."
$resourceGroups = az group list --query "[?location=='$PrimaryRegion' && name like '$ResourceGroupFilter'].name" -o json | ConvertFrom-Json

if (-not $resourceGroups -or $resourceGroups.Count -eq 0) {
    Write-LogMessage "No resource groups found in $PrimaryRegion with filter '$ResourceGroupFilter'" -Level "Error"
    exit 1
}

Write-LogMessage "Found $($resourceGroups.Count) resource group(s) in $PrimaryRegion" -Level "Success"

# Create output directory for Terraform configurations
$baseOutputDir = "./dr-terraform"
if (-not (Test-Path -Path $baseOutputDir)) {
    New-Item -Path $baseOutputDir -ItemType Directory | Out-Null
}

# Process each resource group
foreach ($resourceGroup in $resourceGroups) {
    Write-LogMessage "Processing resource group: $resourceGroup" -Level "Info"
    
    # Check if corresponding DR resource group already exists
    $drResourceGroupName = $resourceGroup.Replace($PrimaryRegion, $DRRegion) + $DRSuffix
    $drResourceGroupExists = az group exists --name $drResourceGroupName
    
    if ($drResourceGroupExists -eq "true" -and $SkipExistingResources) {
        Write-LogMessage "DR resource group $drResourceGroupName already exists. Skipping." -Level "Warning"
        continue
    }
    
    # Create Terraform configuration for this resource group
    $outputDir = Join-Path -Path $baseOutputDir -ChildPath $resourceGroup
    $outputDir = Export-ResourceGroupToTerraform -ResourceGroupName $resourceGroup -OutputDirectory $outputDir
    
    # Analyze compute resources
    $computeResources = Analyze-ComputeResources -ResourceGroupName $resourceGroup
    
    # Generate Terraform configuration for compute resources
    Generate-ResourceTerraformConfig -ComputeResources $computeResources -OutputDirectory $outputDir
    
    # Create DR resource group if WhatIf is not specified
    if (-not $WhatIf) {
        if ($drResourceGroupExists -ne "true") {
            Write-LogMessage "Creating DR resource group: $drResourceGroupName..." -Level "Info"
            az group create --name $drResourceGroupName --location $DRRegion --tags Source=$resourceGroup DR=True
            
            if ($LASTEXITCODE -eq 0) {
                Write-LogMessage "Created resource group $drResourceGroupName" -Level "Success"
            } else {
                Write-LogMessage "Failed to create resource group $drResourceGroupName" -Level "Error"
            }
        }
    } else {
        Write-LogMessage "WhatIf: Would create resource group $drResourceGroupName in $DRRegion" -Level "Info"
    }
}

Write-LogMessage "DR environment sync completed." -Level "Success"
Write-LogMessage "Terraform configurations have been generated in $baseOutputDir" -Level "Success"
Write-LogMessage "Next steps:" -Level "Info"
Write-LogMessage "1. Review and customize the generated Terraform configurations" -Level "Info"
Write-LogMessage "2. Set up Terraform state storage using Setup-TerraformStateStorage.ps1" -Level "Info"
Write-LogMessage "3. Initialize and apply the Terraform configurations for each resource group" -Level "Info"

#endregion
